---
layout: post
title: 리액트 쿼리로 상태 관리하기
categories: react, react-query
author: tyLee
date: "2022-10-27 09:00:00 +0900"
---

-- 나는 v3인 이전 버전으로 공부해서 최신 버전인 v4버전은 자세히는 모르고 있는 상태고 추후 공부 할 예정이다. 그래서 이 글은 v3을 기준으로 정리하였다.

<br>

### 리액트 쿼리란?

> 리액트 쿼리는 종종 React에 대한 누락된 데이터 가져오기 라이브러리로 설명되지만 보다 기술적인 용어로 말하면 React 애플리케이션에서 서버 상태를 가져오고, 캐싱하고, 동기화하고 업데이트하는 작업을 쉽게 만듭니다.<공식문서>

쉽게 말해서 리액트 쿼리는 ~

<br>

### 지원
- 

<br>

### React Query Devtools

React-Query Devtools을 통해 개발자도구를 브라우저에서 간편하게 확인할 수 있다.  
쿼리 데이터(Query, useQuery가 반환하는 객체 속성값)는 4가지 상태를 가진다.  

1. fresh : 새롭게 추가된 쿼리 인스턴스이며, 만료되지 않은 쿼리. 컴포넌트의 mount, update 시에 데이터를 재요청하지 않음.
2. fetching : 요청 상태인 쿼리.
3. stale : 데이터 패칭이 완료되어 만료된 쿼리. stale 상태의 같은 쿼리를 useQuery로 재호출하여 컴포넌트 마운트를 한다면 캐싱된 데이터가 반환됨.
4. inactive : 비활성 쿼리로써 사용하지 않음. 5분 뒤에 가비지 콜렉터가 캐시에서 제거함.
5. delete : 가비지 콜렉터에 의하여 캐시에서 제거된 쿼리.

<br>

리액트 쿼리는 서버 데이터 캐시를 관리한다.  
리액트 코드에 서버 데이터가 필요할 때 페치나 엑시오스를 사용해 서버로 바로 이동하지 않고 리액트 쿼리를 캐시를 요청한다.  
리액트 쿼리의 역할은 리액트 쿼리 클라이언트를 어떻게 구성했느냐 해당 캐시의 데이터를 유지 관리하는 것이다.  
데이터를 관리하는 것은 리액트 쿼리지만 서버의 새 데이터로 캐시를 업데이트하는 시기를 설정하는 것은 사용자의 몫이다.  

<br>

리액트 쿼리는 가장 기본적인 데이터 패칭 기능과 로딩 및 오류 상태 관리이다.  
이를 통해 데이터가 로딩되었을 때와 isLoading, isError 이 둘은 데이터가 로딩 중인지 여부와 데이터를 가져올 때 오류가 있는지 여부를 알려주는 불리언이다.  
isFecthing 안에 isLoading 개념이다, 둘의 차이는 isFecthing은 비동기 쿼리가 해결되지 않았을 때 아직 페칭을 완료하지 않았다는 의미지만 쿼리가 엑시오스 호출 또는 그래프큐엘 호출일 수도 있다.  
isLoading은 가져오는 상태에 있음을 의미, 쿼리 함수가 아직 해결되지 않은 것이다. 그리고 캐시된 데이터도 없다.  
이 쿼리를 만든적이 없다는 뜻, 데이터를 가져오는 중이고 표시할 캐시 데이터도 없다는 것이다.  
이 둘의 차이점은 페이지네이션을 할 때 캐시된 데이터가 있을 때와 없을때를 구분해야 한다는 사실을 알게 될 것이다.  

<br>

리액트 쿼리에서 데이터가 만료된 상태를 stale라고 한다.  
만료된 데이터는 오래된 식빵과 비슷하다. 리액트 쿼리에서 데이터가 만료 됐다는 뜻은 어떤 뜻일까?  
데이터 리페칭은 만료된 데이터에서만 실행한다.  
데이터 리페칭 실행에는 만료된 데이터 외에도 여러 트리거가 있다.  
보통은 리페칭이 실행될 경우라도 데이터가 만료되지 않으면 리페칭은 실행되지 않는다.  
데이터가 만료된 경우에만 시작한다.  
staleTime의 기본값은 0이다, 이것을 옵션값으로 타이머 설정해두면 특정 시간후 리페칭이 멈추고 리페칭된다.  
왜 기본 값이 0인가?  
왜 항상 최신상태로 유지되는가?  
데이터는 항상 만료 상태이므로 서버에서 다시 가져와야 한다고 가정한다는 뜻이다, 그러면 실수로 클라이언트에게 만료된 데이터를 제공할 가능성이 훨씬 줄어든다.  

<br>

staleTime과 cacheTime의 차이  
staleTime은 리페칭할 때 고려 사항이다.  
캐시는 나중에 다시 필요할 수도 있는 데이터용이다.  
만료된 데이터가 위험할 수 있는 애플리케이션의 경우는 캐쉬타임을 0으로 설정하면 된다.  

<br>

useQuery(“”, 비동기 함수, 옵션)  

<br>

다른 쿼리키를 부여하는 방법은 쿼리 키를 배(array)로 업데이트해서 가져오는 페이지 번호를 포함하도록 하면 된다.  

<br>

사용자가 다음 혹은 이전 페이지를 누르면 currentPage 상태를 업데이트 하게 된다. 그럼 리액트 쿼리가 바뀐 쿼리 키를감지하고 새로운 쿼리를 실행해서 새 페이지가 표시된다.  

<br>

페이지네이션을 구현할 때 해당 키 값을 배열로 부여해주면 된다. 하지만 클라이언트에서 페이지 이동 시 깜빡임이 일어나 ux 방해가 된다. 이를 해결하기 위해 데이터 프리페칭을 이용하여 해결해주면 된다.  
깜빡임이 일어나는 이유는 페이지가 캐시에 없기 때문, 버튼을 누를 때 마다 페이지 로딩되길 기다려야 됨  

<br>

데이터 프리페칭 (data-fetching)  
프리페칭은 데이터를 캐시에 추가하며 구성할 수 있긴 하지만 기본값으로 만료(state) 상태이다.  
즉 데이터를 사용하고자 할 때 만료 상태에서 데이터를 다시 가져온다.  
데이터를 다시 가져오는 중에는 캐시에 있는 데이터를 이용해 앱에 나타낸다.  
물론 캐시가 만료되지 않는 다는 가정하다.  
데이터 프리페칭은 미리 데이터를 가져와 캐시에 담아두는 것  

<br>

prefetchingQuery는 useQuery와 비슷함. 쿼리 키가 바뀔 때도 지난 데이터를 유지해서 혹여나 이전 페이지로 돌아갔을 때 캐시에 해당 데이터가 있도록 하는 것이 옵션에 keepPreviousData: true로 해주면 됨, 바뀌는 배경(UI)과 데이터가 안바뀔 때와 일치해야할 때 적합, 일치하지 않을 때 사용하면 새 데이터를 보여 주기 전에 이전 데이터를 보여주기 때문에 겹쳐짐

<br>

isFetching의 경우 async 쿼리 함수가 해결되지 않았을 떄 참에 해당한다.  
아직 데이터를 가져오는 중에 속한다. isLoading은 isFetching이 참이면서 쿼리에 대해 캐시된 데이터가 없다는 뜻이다.   
즉 isLoading이 참이면 isFetching도 참이다.  
IsLoading은 캐시된 데이터가 없고 데이터를 가져오는 상황에 해당하는 isFetching의 부분 집합이다.  

<br>

Mutations(변이)  
변이는 서버에 데이터를 업데이트 하도록 서버에 네트워크 호출을 실시한다.  
따라서 이 경우 블로그 포스트를 추가하거나 삭제하거나 제목을 변경한다.
서버 사이드 이펙트 수행에 사용되는 useMutation  

<br>

staleTime은 데이터가 사용 가능한 상태로 유지되는 시간이다. 서버로 돌아가 데이터가 여전히 정확한지 확인해야 하는 시점까지다.  
cacheTime은 데이터가 비활성화된 이후 남아 있는 시간이다. 캐시된 데이터는 쿼리를 다시 실행했을 떄 사용된다. 데이터가 최신 상태인지 서버에서 확인하는 동안 자리 표시자로 사용자에게 보여지게 된다.  

<br>

패키지 다운 후 QueryClient를 생성해서 QueryProvider에 추가 했다. 
프로바이더로 감싼다.
왜? 모든 자식 컴포넌트가 캐시와 훅을 사용할 수 있기 때문  
useQuery 훅을 이용하여 데이터를 서버에서 가져오고 최신 상태인지 확인 할 수 있다.  
isLoading, isFetching, error를 이용해 특정 쿼리의 상태를 사용자에게 알려줄 때 사용한다.  
무한 스크롤은 사용자가 스크롤 할 때마다 새로운 데이터를 가져오는 것이다.  

<br>

NODE_ENV
리액트 쿼리 개발자툴은 노드 환경을 변경할 수 있을때만 보이게 된다. 노드 환경이 프로덕션으로 설정되어 있지않기 때문에 이걸 cra로 개발 모드에 있을 때 노드 환경은 개발 할 수 있다. 직접 만들어서 빌드를 실행하는 경우 노드 환경은 프로덕션이 된다.  
개발 모드에서 실행하는 동안은 볼 수 있지만 직접 만든 경우는 도구가 보이지 않는다.  
cra로 환경셋팅 한 경우 NODE_ENV 환경 변수가 내장으로 자동으로 셋팅 되어지기 때문에 노출 위험이 줄어든다.
vi .env

<br>

InfiniteScroll : react-infinite-scroller  
1. loadMore = {fetchNextPage}
2. hasMore = {hasNextPage}

loadMore는 데이터가 더 필요할 떄 불러와 useInfiniteQuery에서 나온 fetchNextPage 함숫값을 이용한다.  
hasNextPage는 useInfiniteQuery에서 나온 객첼르 해체한 값을 이용한다.  

<br>

무한 스크롤 컴포넌트는 스스로 페이지의 끝에 도달했음을 인식하고 fetchNextPage를 불러오는 기능이다.  
그러면 데이터 프로퍼티에서 데이터에 접근할 수 있는데 useInfiniteQuery 컴포넌트에서 나온 객체를 이용한다.  
배열인 페이지 프로퍼티를 이용해 그 페이지 배열의 맵을 만들어 데이터를 표시할 수 있게 된다.  
양방향 스크롤(Bi-directional Scrolling)  
데이터 중간부터 시작할 때 유용하다. 그러면 시작점 이후 뿐 아니라 이전의 데이터도 가져와야 한다.  

<br>

useQuery를 이용할 때 데이터 반환 시 리죨브가 되기 전 데이터를 못받아 와서 map 에러가 반환됨.  
이럴 때는 데이터에 대한 폴백값을 만들어 서버에서 데이터를 받지 않고 캐시가 비어있을 경우 undefined를 반환하여 에러 캐치  

<br>

UseIsFetching은 현재 가져오기 중인 쿼리가 있는지를 우리에게 알려주는 훅이다.  
useIsFetching 훅이 불리언을 반환해서 쿼리를 가져오고 있는지 알려준다. 이 값을이용해 로딩 스피너의 디스플레이 속성을 켰다 껐다 할 수 있다.  
로딩 스피너는 앱 컴포넌트 중 하나로 항상 존재해야 하지만 디스플레이를 바꾸는 것은 useIsFetching에 따라 바꿀 수 있다.  

<br>

prefetchQuery는 queryClient의 메서드이고,   데이터는 서버에서 오기 때문에 데이터를 가져오기 위해 서버로 이동하고 데이터는 캐시에 추가된다.   1회성이다.

<br>

setQueryData는 queryClient의 메서드이고, useQuery를 실행하지 않고 쿼리 데이터를 캐시에 추가하는 또 다른 방법이다. 클라이언트에서 데이터를 가져온다. 변이에 대한 응답으로 나온 데이터이다. queryClient에서 setQueryData 메소드를 사용하여 캐시에 데이터를 추가하면 useQuery가 데이터를 요청할 때 캐시가 해당 데이터를 제공하도록 할 수 있다.

<br>

placeholderData는 useQuery에 대한 메서드이다. useQuery이 실행될 때 데이터를 제공하기 때문에 클라이언트에서 데이터를 가져오고 캐시에는 추가되지 않는다. 고정값 또는 함수로 사용할 수 있다. 자리 표시자 데이터값을 동적으로 결정하는 함수를 사용하려는 경우 사용하는 것이 가장 좋다. 표시할 데이터가 없는 경우 사용하는 표시용 데이터일 뿐이며 다시 사용할 일이 없기 때문에 캐시에 추가되지 않는다.

<br>

initialData는 useQuery의 메서드이고, 클라이언트에서 제공한다. 캐시에 추가해야하는 데이터이다.

<br>

새 데이터가 로드되지 않는 이유는 모든 쿼리에 동일한 키를 사용하기 때문.  
쿼리 데이터는 만료(stale) 상태이지만 리페치를 트리거할 대상이 없다.  
쿼리키를 종속성 배열로 해야한다. 그렇게 하지 않으면 쿼리가 데이터를 다시 가져오지 못하거나 원할 때 새 데이터를 가져오지 못할 수도 있기 때문이다.

<br>

셀렉트(select) 옵션을 사용해 데이터를 변환하는 방법 - 필터링과 리페치를 사용  
셀렉트 함수는 데이터와 함수가 모두 변경되었을 경우에만 실행된다.  
셀렉트는 프리페치의 옵션이 아니므로 프리페치된 데이터에 추가할 수 없다.  
useQuery 옵션이다.  

<br>

리페칭을 위해서 서버가 만료 데이터를 업데이트 하는 것이다. 즉, 일정 시간이 지나면 서버가 만료된 데이터를 삭제하는데 자동으로 된다. 이런 리페칭은 페이지를 벗어났다가 다시 돌아왔을 때 인디게이터를 볼 수 있다. 서버를 통해 데이터가 업데이트 안 된게 확실한지 확인해야 하는 인디게이터다.  
Stale 쿼리는 어떤 조건 하에서 자동적으로 다시 가져오기가 된다. 새로운 쿼리 인스턴스가 많거나, 쿼리 키가 처음 호출된다거나, 쿼리를 호출하는 반응 컴포넌트를 증가시킨다거나, 창을 재포커스 한다거나, 만료된 데이터의 업데이트 여뷰를 확인할 수 있는 네트워크가 다시 연결된 경우 리페칭 된다. 또한 리페칭 간격이 지난 겨우도 해당되는데 이 경우는 간격에 리페칭을 해서 서버를 풀링하고 사용자 조치가 없더라도 데이터가 업데이트 되는 경우다.  

<br>

refetchOnMount, refetchOnWindowFocus, refetchOnReconnect은 불리언값이고 refetchInterval은 밀리초 단위의 시간이다.  
리액트 쿼리는 리페치에 꽤 강한 프로그램이다.  
3개의 불리언 옵션들은 기본값이 트루이다.  
리페칭을 제한하고 싶을 때는 stale 시간을 증가시키면 된다. 창을 재포커스 하거나 네트워크에 재연결 하는 트리거는 데이터가 실제로 만료된 경우에만 작용하기 때문이다.  
아니면 이 3가지(refetchOnMount, refetchOnWindowFocus, refetchOnReconnect) 불리언 옵션 중 하나 혹은 전체를 끄면 된다.  
리페칭을 제한할 때는 신중해야 한다. 변동이 잦지 않은 데이터에 적용해야 하며 미세한 변동에도 큰 변화를 불러오는 데이터에는 적용하지 말아야 한다. 예를들어 서비스와 직원이 해당 된다.   서비스와 직원 정보는 자주 변하지 않으니까 리페칭을 제한해도 된다. 게다가 몇 분간 사라진다 해도 사용자들이 큰 불편함을 느끼지도 않을 것이다. 반면에 실시간 정보가 중요한 예약은 사용자에게 훨씬 중요한 데이터이다. 리페칭을 제한하면 네트워크 호출을 줄일 수 있다.

<br>

홈페이지는 프리페칭으로 만료 타임이나 캐싱 타임이 없다. 그래서 옵션이 기본 값이다.  
캐싱 타임은 기본값이 5분이다.  
만료 타임이 캐싱 타임을 초과한다는 건 리페칭을 실행시키는 동안 보여 줄 화면이 없다는 것이다.  
캐싱 타임에 속한 만료 타임이 리페칭 여부를 결정하는 어떤 호출에든 적용된다.  
리페칭을 쿼리 전역으로 사용하는 경우 - 변이(Mutation)를 만들어 데이터를 무효화시키면 리페칭됨  
1. 예약
2. 사용자 프로필 업데이트

전역 옵션을 설정하는 방법은 queryClient 훅에 옵션을 넣어주면 됨  
queryClient에 전역 옵션을 넣은 경우는 그만큼 리페칭이 자주 발생하지 않는다는 것  
staleTime과 cacheTime은 프리페칭에 적용이 됨  
서버에서 데이터 변경 될 때 리페칭 데이터 주기는 옵션 refetchInterval을 이용  

### 끝마치며

-

<br>

### 참조

> <https://tecoble.techcourse.co.kr/post/2021-10-01-react-query-error-handling/>  
> <https://devkkiri.com/post/6783e9be-280a-469d-b377-dac40e7b214f>  
> <https://parang.gatsbyjs.io/react/2022-react-02/>  
> <https://tech.kakao.com/2022/06/13/react-query/>  
> <https://develop-obm.tistory.com/32>  

