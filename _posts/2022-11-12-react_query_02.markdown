---
layout: post
title: 리액트 쿼리로 상태 관리하기 下
categories: react, react-query
author: tyLee
date: "2022-11-12 09:00:00 +0900"
---

-- 리액트와 잘 맞는 상태관리 라이브러리는 여러 개가 있다. 상태를 무엇으로 관리해야 할지 고민하고 있던 중 리액트 내장 함수이자 가장 기본적인 Context API부터 사용해보고 싶었고, 마침 내가 포트폴리오로 만들고 있던 프로젝트가 소규모였기에 적합하다고 판단하여 Context API부터 사용하게 되었다. 그 이후로 상태관리를 더 깊게 공부 하고 싶어 React-Query를 유데미 인강을 보면서 공부하기 시작했다. 리액트 쿼리를 선택한 이유는 비동기적이고, 쉽게 에러를 외부에 위임하는 것과 페이지네이션 기능, 무한 스크롤 기능 등등 강력한 기능들을 쉽고 간편하게 지원해줄 수 있다는 것에 택하게 되었다. 이 글은 v3 버전으로 공부하고 정리한 글이다.

<br>
<br>

<img src="{{'/assets/img/query/react_query_img.png' | relative_url}}" style="margin: 0 auto;">

<br>

### 목차

1. <a href="#none">페이지 매김, 프리페칭과 변이</a>
2. <a href="#none">무한 쿼리</a>
3. <a href="#none">데이터 변환과 데이터 리페칭</a>

<hr>
<br>

### 1. 페이지 매김, 프리페칭과 변이

데이터 프리페칭 (data-fetching)  
프리페칭은 데이터를 캐시에 추가하며 구성할 수 있긴 하지만 기본값으로 만료(state) 상태이다.  
즉 데이터를 사용하고자 할 때 만료 상태에서 데이터를 다시 가져온다.  
데이터를 다시 가져오는 중에는 캐시에 있는 데이터를 이용해 앱에 나타낸다.  
물론 캐시가 만료되지 않는 다는 가정하다.  
데이터 프리페칭은 미리 데이터를 가져와 캐시에 담아두는 것

<br>

prefetchingQuery는 useQuery와 비슷함. 쿼리 키가 바뀔 때도 지난 데이터를 유지해서 혹여나 이전 페이지로 돌아갔을 때 캐시에 해당 데이터가 있도록 하는 것이 옵션에 keepPreviousData: true로 해주면 됨, 바뀌는 배경(UI)과 데이터가 안바뀔 때와 일치해야할 때 적합, 일치하지 않을 때 사용하면 새 데이터를 보여 주기 전에 이전 데이터를 보여주기 때문에 겹쳐짐

<br>

isFetching의 경우 async 쿼리 함수가 해결되지 않았을 떄 참에 해당한다.  
아직 데이터를 가져오는 중에 속한다. isLoading은 isFetching이 참이면서 쿼리에 대해 캐시된 데이터가 없다는 뜻이다.  
즉 isLoading이 참이면 isFetching도 참이다.  
IsLoading은 캐시된 데이터가 없고 데이터를 가져오는 상황에 해당하는 isFetching의 부분 집합이다.

<br>

staleTime은 데이터가 사용 가능한 상태로 유지되는 시간이다. 서버로 돌아가 데이터가 여전히 정확한지 확인해야 하는 시점까지다.  
cacheTime은 데이터가 비활성화된 이후 남아 있는 시간이다. 캐시된 데이터는 쿼리를 다시 실행했을 떄 사용된다. 데이터가 최신 상태인지 서버에서 확인하는 동안 자리 표시자로 사용자에게 보여지게 된다.

<br>

InfiniteScroll : react-infinite-scroller

1. loadMore = {fetchNextPage}
2. hasMore = {hasNextPage}

loadMore는 데이터가 더 필요할 떄 불러와 useInfiniteQuery에서 나온 fetchNextPage 함숫값을 이용한다.  
hasNextPage는 useInfiniteQuery에서 나온 객체르 해체한 값을 이용한다.

<br>

### 2. 무한 쿼리

무한 스크롤 컴포넌트는 스스로 페이지의 끝에 도달했음을 인식하고 fetchNextPage를 불러오는 기능이다.  
그러면 데이터 프로퍼티에서 데이터에 접근할 수 있는데 useInfiniteQuery 컴포넌트에서 나온 객체를 이용한다.  
배열인 페이지 프로퍼티를 이용해 그 페이지 배열의 맵을 만들어 데이터를 표시할 수 있게 된다.  
양방향 스크롤(Bi-directional Scrolling)  
데이터 중간부터 시작할 때 유용하다. 그러면 시작점 이후 뿐 아니라 이전의 데이터도 가져와야 한다.

<br>

useQuery를 이용할 때 데이터 반환 시 리죨브가 되기 전 데이터를 못받아 와서 map 에러가 반환됨.  
이럴 때는 데이터에 대한 폴백값을 만들어 서버에서 데이터를 받지 않고 캐시가 비어있을 경우 undefined를 반환하여 에러 캐치

<br>

UseIsFetching은 현재 가져오기 중인 쿼리가 있는지를 우리에게 알려주는 훅이다.  
useIsFetching 훅이 불리언을 반환해서 쿼리를 가져오고 있는지 알려준다. 이 값을이용해 로딩 스피너의 디스플레이 속성을 켰다 껐다 할 수 있다.  
로딩 스피너는 앱 컴포넌트 중 하나로 항상 존재해야 하지만 디스플레이를 바꾸는 것은 useIsFetching에 따라 바꿀 수 있다.

<br>

prefetchQuery는 queryClient의 메서드이고, 데이터는 서버에서 오기 때문에 데이터를 가져오기 위해 서버로 이동하고 데이터는 캐시에 추가된다. 1회성이다.

<br>

setQueryData는 queryClient의 메서드이고, useQuery를 실행하지 않고 쿼리 데이터를 캐시에 추가하는 또 다른 방법이다. 클라이언트에서 데이터를 가져온다. 변이에 대한 응답으로 나온 데이터이다. queryClient에서 setQueryData 메소드를 사용하여 캐시에 데이터를 추가하면 useQuery가 데이터를 요청할 때 캐시가 해당 데이터를 제공하도록 할 수 있다.

<br>

placeholderData는 useQuery에 대한 메서드이다. useQuery이 실행될 때 데이터를 제공하기 때문에 클라이언트에서 데이터를 가져오고 캐시에는 추가되지 않는다. 고정값 또는 함수로 사용할 수 있다. 자리 표시자 데이터값을 동적으로 결정하는 함수를 사용하려는 경우 사용하는 것이 가장 좋다. 표시할 데이터가 없는 경우 사용하는 표시용 데이터일 뿐이며 다시 사용할 일이 없기 때문에 캐시에 추가되지 않는다.

<br>

initialData는 useQuery의 메서드이고, 클라이언트에서 제공한다. 캐시에 추가해야하는 데이터이다.

<br>

### 3. 데이터 변환과 데이터 리페칭

새 데이터가 로드되지 않는 이유는 모든 쿼리에 동일한 키를 사용하기 때문.  
쿼리 데이터는 만료(stale) 상태이지만 리페치를 트리거할 대상이 없다.  
쿼리키를 종속성 배열로 해야한다. 그렇게 하지 않으면 쿼리가 데이터를 다시 가져오지 못하거나 원할 때 새 데이터를 가져오지 못할 수도 있기 때문이다.

<br>

셀렉트(select) 옵션을 사용해 데이터를 변환하는 방법 - 필터링과 리페치를 사용  
셀렉트 함수는 데이터와 함수가 모두 변경되었을 경우에만 실행된다.  
셀렉트는 프리페치의 옵션이 아니므로 프리페치된 데이터에 추가할 수 없다.  
useQuery 옵션이다.

<br>

리페칭을 위해서 서버가 만료 데이터를 업데이트 하는 것이다. 즉, 일정 시간이 지나면 서버가 만료된 데이터를 삭제하는데 자동으로 된다. 이런 리페칭은 페이지를 벗어났다가 다시 돌아왔을 때 인디게이터를 볼 수 있다. 서버를 통해 데이터가 업데이트 안 된게 확실한지 확인해야 하는 인디게이터다.  
Stale 쿼리는 어떤 조건 하에서 자동적으로 다시 가져오기가 된다. 새로운 쿼리 인스턴스가 많거나, 쿼리 키가 처음 호출된다거나, 쿼리를 호출하는 반응 컴포넌트를 증가시킨다거나, 창을 재포커스 한다거나, 만료된 데이터의 업데이트 여뷰를 확인할 수 있는 네트워크가 다시 연결된 경우 리페칭 된다. 또한 리페칭 간격이 지난 겨우도 해당되는데 이 경우는 간격에 리페칭을 해서 서버를 풀링하고 사용자 조치가 없더라도 데이터가 업데이트 되는 경우다.

<br>

refetchOnMount, refetchOnWindowFocus, refetchOnReconnect은 불리언값이고 refetchInterval은 밀리초 단위의 시간이다.  
리액트 쿼리는 리페치에 꽤 강한 프로그램이다.  
3개의 불리언 옵션들은 기본값이 트루이다.  
리페칭을 제한하고 싶을 때는 stale 시간을 증가시키면 된다. 창을 재포커스 하거나 네트워크에 재연결 하는 트리거는 데이터가 실제로 만료된 경우에만 작용하기 때문이다.  
아니면 이 3가지(refetchOnMount, refetchOnWindowFocus, refetchOnReconnect) 불리언 옵션 중 하나 혹은 전체를 끄면 된다.  
리페칭을 제한할 때는 신중해야 한다. 변동이 잦지 않은 데이터에 적용해야 하며 미세한 변동에도 큰 변화를 불러오는 데이터에는 적용하지 말아야 한다. 예를들어 서비스와 직원이 해당 된다. 서비스와 직원 정보는 자주 변하지 않으니까 리페칭을 제한해도 된다. 게다가 몇 분간 사라진다 해도 사용자들이 큰 불편함을 느끼지도 않을 것이다. 반면에 실시간 정보가 중요한 예약은 사용자에게 훨씬 중요한 데이터이다. 리페칭을 제한하면 네트워크 호출을 줄일 수 있다.

<br>

홈페이지는 프리페칭으로 만료 타임이나 캐싱 타임이 없다. 그래서 옵션이 기본 값이다.  
캐싱 타임은 기본값이 5분이다.  
만료 타임이 캐싱 타임을 초과한다는 건 리페칭을 실행시키는 동안 보여 줄 화면이 없다는 것이다.  
캐싱 타임에 속한 만료 타임이 리페칭 여부를 결정하는 어떤 호출에든 적용된다.  
리페칭을 쿼리 전역으로 사용하는 경우 - 변이(Mutation)를 만들어 데이터를 무효화시키면 리페칭됨

1. 예약
2. 사용자 프로필 업데이트

전역 옵션을 설정하는 방법은 queryClient 훅에 옵션을 넣어주면 됨  
queryClient에 전역 옵션을 넣은 경우는 그만큼 리페칭이 자주 발생하지 않는다는 것  
staleTime과 cacheTime은 프리페칭에 적용이 됨  
서버에서 데이터 변경 될 때 리페칭 데이터 주기는 옵션 refetchInterval을 이용

<br>

리액트 쿼리에서 데이터가 만료된 상태를 stale라고 한다.  
만료된 데이터는 오래된 식빵과 비슷하다. 리액트 쿼리에서 데이터가 만료 됐다는 뜻은 어떤 뜻일까?  
데이터 리페칭은 만료된 데이터에서만 실행한다.  
데이터 리페칭 실행에는 만료된 데이터 외에도 여러 트리거가 있다.  
보통은 리페칭이 실행될 경우라도 데이터가 만료되지 않으면 리페칭은 실행되지 않는다.  
데이터가 만료된 경우에만 시작한다.  
staleTime의 기본값은 0이다, 이것을 옵션값으로 타이머 설정해두면 특정 시간후 리페칭이 멈추고 리페칭된다.  
왜 기본 값이 0인가?  
왜 항상 최신상태로 유지되는가?  
데이터는 항상 만료 상태이므로 서버에서 다시 가져와야 한다고 가정한다는 뜻이다, 그러면 실수로 클라이언트에게 만료된 데이터를 제공할 가능성이 훨씬 줄어든다.

<br>

staleTime과 cacheTime의 차이  
staleTime은 리페칭할 때 고려 사항이다.  
캐시는 나중에 다시 필요할 수도 있는 데이터용이다.  
만료된 데이터가 위험할 수 있는 애플리케이션의 경우는 캐쉬타임을 0으로 설정하면 된다.

<br>

Mutations(변이)  
변이는 서버에 데이터를 업데이트 하도록 서버에 네트워크 호출을 실시한다.  
따라서 이 경우 블로그 포스트를 추가하거나 삭제하거나 제목을 변경한다.
서버 사이드 이펙트 수행에 사용되는 useMutation

<br>

다른 쿼리키를 부여하는 방법은 쿼리 키를 배(array)로 업데이트해서 가져오는 페이지 번호를 포함하도록 하면 된다.

<br>

사용자가 다음 혹은 이전 페이지를 누르면 currentPage 상태를 업데이트 하게 된다. 그럼 리액트 쿼리가 바뀐 쿼리 키를감지하고 새로운 쿼리를 실행해서 새 페이지가 표시된다.

<br>

페이지네이션을 구현할 때 해당 키 값을 배열로 부여해주면 된다. 하지만 클라이언트에서 페이지 이동 시 깜빡임이 일어나 ux 방해가 된다. 이를 해결하기 위해 데이터 프리페칭을 이용하여 해결해주면 된다.  
깜빡임이 일어나는 이유는 페이지가 캐시에 없기 때문, 버튼을 누를 때 마다 페이지 로딩되길 기다려야 됨

<br>
<br>

### 끝마치며

면접 보러 다니면서 리액트 쿼리를 공부하고 있었다. 지인 형이 추천 회사에 최종 합격 후 입사 전 리액트 쿼리 미리 공부해오면 좋겠다 해서 더 몰입해서 공부하고 있는 중이다. 실무에서 바로 응용해서 쓸 수 있을지는 모르겠지만, 코드는 읽을 수 있을 것만 같은 근자감이 생겼다.

<br>

### 참조

> <https://tecoble.techcourse.co.kr/post/2021-10-01-react-query-error-handling/>  
> <https://devkkiri.com/post/6783e9be-280a-469d-b377-dac40e7b214f>  
> <https://parang.gatsbyjs.io/react/2022-react-02/>  
> <https://tech.kakao.com/2022/06/13/react-query/>
